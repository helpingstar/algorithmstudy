# **알고리즘 리뷰**

## **2021-11-30**

### **1. [BOJ 2036](https://www.acmicpc.net/problem/2036)**

#### **내 생각 :** 
큰 순서대로 제거한다는 생각을 했지만, 양수를 먼저 처리하든 음수를 먼저 처리하든 크게 상관이 없다는 것을 깨달음
#### **복습한 것:**

```python
# sorted()

>>> sorted([5, 2, 3, 1, 4])
[1, 2, 3, 4, 5]
```
모든 Iterable을 받아들인다. 새로운 정렬된 리스트를 반환한다.

```python
# list.sort()

>>> a = [5, 2, 3, 1, 4]
>>> a.sort()
>>> a
[1, 2, 3, 4, 5]
```
리스트를 제자리에서 수정한다 ( `None`을 반환한다 ) 일반적으로 `sorted()` 보다 덜 편리하다, 하지만 원래 목록이 필요하지 않다면 이것이 더 효율적이다.

#### **최적화 표**
| 메모리 | 시간 |
| ------ | ---- |
| 33140  | 3752 |

### **2. [BOJ 16288](https://www.acmicpc.net/problem/16288)**
#### **내 생각 :**
문제로 제대로 푼 것인지 잘 모르겠다.
줄을 세우기 때문에 줄을 세우는 풀이로 한 것인데 관련된 문제를 더 풀어봐야 할 것 같다.
#### **최적화 표**
| 메모리 | 시간 |
| ------ | ---- |
| 29200  | 68 |

### **3. [HL_bigger-is-greater](https://www.hackerrank.com/challenges/bigger-is-greater/problem)**

#### **복습한 것:**
단어 하나를 `list`에 `char` 단위로 넣고 싶을 때
```python
# list(str)

>>> a = 'abcdefg'
>>> list(a)
['a', 'b', 'c', 'd', 'e', 'f', 'g']
```

문자열 뒤집기
```python
# string
>>> string = 'thank you everyone'
>>> string[::-1]
'enoyreve uoy knaht'

# list
>>> list = [1, 2, 3, 4, 5, 6]
>>> list[::-1]
[6, 5, 4, 3, 2, 1]
```
리스트 병합
```python
>>> first = [1, 2, 3, 4]
>>> second = [5, 6, 7, 8]
>>> first + second
[1, 2, 3, 4, 5, 6, 7, 8]
```
## **2021-12-04**

### **1. [Programmers 2036](https://programmers.co.kr/learn/courses/30/lessons/42861)**
#### **내 생각 :**
정렬이 된 리스트를 처음부터 다루는 문제라면 반복마다 `sort()`를 하는 것이 아니라 처음부터 `heapq`를 다루는게 효율적이라는 것을 알게 되었다.

내 사례 : `list`로 반복마다 `sort()`를 했을 때 정확도는 다 맞았으나 효율성에서 탈락되어 `heapq`로 바꾸니 해결되었다.

## **2021-12-07**

### **1. [BOJ 18405](https://www.acmicpc.net/problem/18405)**
#### **내 생각 :**
결국 BFS의 확장판이라는 생각이 들었다. 한 객체가 1차원적으로 BFS를 수행한다면 여러개가 수행한다면 그것은 2차원 BFS느낌이어서 쉽게 풀 수 있었다.

## **2021-12-09**

### **1. [BOJ 11651](https://www.acmicpc.net/problem/11651)**
#### **내 생각:**
2개의 요소를 가진 튜플 여러개를 가진 리스트를 정렬할 때

1차 기준 : index `1`, 2차 기준 : index `0` 으로 하려할 때 `sort()`에서 `key` 설정할 때 `lambda x: x[1]`와 `lambda x: (x[1], x[0])` 둘의 차이가 있었다 **이유는 모르겠다** 하지만 다음부터는 제대로 정렬 조건을 넣어야겠다.
#### **복습한 것 :**
```python
# 람다의 형태
list.sort(key=lambda x: (x[0], x[1]))
```
### **2. [BOJ 10989](https://www.acmicpc.net/problem/10989)**
#### **내 생각:**
계수정렬을 고려하지 않아서 풀지 못했으나, 힌트를 보고 계수정렬로 풀었다. 처음에는 시간을 최적화 하기 위해 *숫자 * 계수* 로 출력하려 했으나 메모리가 추가하여 각각 하나씩 출력하여 메모리를 줄이고 출력 시간을 늘렸다